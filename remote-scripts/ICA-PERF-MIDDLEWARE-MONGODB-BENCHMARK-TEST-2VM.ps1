<#-------------Create Deployment Start------------------#>
Import-Module .\TestLibs\RDFELibs.psm1 -Force
$result = ""
$testResult = ""
$resultArr = @()
$threads=$currentTestData.threads

$isDeployed = DeployVMS -setupType $currentTestData.setupType -Distro $Distro -xmlConfig $xmlConfig
if ($isDeployed)
{
	try
	{
		$noServer = $true
		$noClient = $true
		foreach ( $vmData in $allVMData )
		{
			if ( $vmData.RoleName -imatch "Server" )
			{
                $serverVMData = $vmData
				$noServer = $false
			}
			elseif ( $vmData.RoleName -imatch "Client" )
			{
				$clientVMData = $vmData
				$noClient = $fase
			}
		}
		if ( $noServer )
		{
			Throw "No any server VM defined. Be sure that, server VM role name matches with the pattern `"*server*`". Aborting Test."
		}
		if ( $noSlave )
		{
			Throw "No any client VM defined. Be sure that, client machine role names matches with pattern `"*client*`" Aborting Test."
		}
		#region CONFIGURE VMs for TEST

		LogMsg "CLIENT VM details :"
		LogMsg "  RoleName : $($clientVMData.RoleName)"
		LogMsg "  Public IP : $($clientVMData.PublicIP)"
		LogMsg "  SSH Port : $($clientVMData.SSHPort)"
		LogMsg "SERVER VM details :"
		LogMsg "  RoleName : $($serverVMData.RoleName)"
		LogMsg "  Public IP : $($serverVMData.PublicIP)"
		LogMsg "  SSH Port : $($serverVMData.SSHPort)"
		
		#
		# PROVISION VMS FOR LISA WILL ENABLE ROOT USER AND WILL MAKE ENABLE PASSWORDLESS AUTHENTICATION ACROSS ALL VMS IN SAME HOSTED SERVICE.	
		#
		##ProvisionVMsForLisa -allVMData $allVMData
		
		#endregion
		
		#region Geting Test Data from remote XML file
		#$mdXMLURL = $($currentTestData.remoteXML)
		#LogMsg "Downloading apache test XML : $mdXMLURL ..."
		#$mdXMLFileName = $($mdXMLURL.Split("/")[$mdXMLURL.Split("/").Count-1])
		#$out = Invoke-WebRequest -Uri $mdXMLURL -OutFile "$LogDir\$mdXMLFileName"
		
		$mdXMLData = [xml](Get-Content -Path ".\XML\Perf_Middleware_MangoDB_2VM.xml") 

		LogMsg "Generating constansts.sh ..."
		$constantsFile = "$LogDir\constants.sh"
		Set-Content -Value "#Generated by Azure Automation." -Path $constantsFile
		foreach ($mdParam in $mdXMLData.config.testCases.test.testParams.param )
		{
			if ($mdParam -imatch "MD_SERVER")
			{
				Add-Content -Value "MD_SERVER=$($serverVMData.InternalIP)" -Path $constantsFile
				LogMsg "MD_SERVER=$($serverVMData.InternalIP) added to constansts.sh"
			}
			else
			{
				Add-Content -Value "$mdParam" -Path $constantsFile
				LogMsg "$mdParam added to constansts.sh"
			}
		}		
		LogMsg "constanst.sh created successfully..."

		LogMsg "Generating MongoDB workload file ..."
		$workloadFile = "$LogDir\workloadAzure"
		Set-Content -Value "#Generated by Azure Automation." -Path $workloadFile
		foreach ($mdParam in $mdXMLData.config.testCases.test.testParams.mdparam )
		{
			Add-Content -Value "$mdParam" -Path $workloadFile 
			LogMsg "$mdParam added to workloadAzure"
		}		
		LogMsg "workloadAzure file created successfully..."
		#endregion

		#region EXECUTE TEST
		Set-Content -Value "/root/performance_middleware_mongod.sh &> mongodConsoleLogs.txt" -Path "$LogDir\StartMONGODTest.sh"
		$out = RemoteCopy -uploadTo $clientVMData.PublicIP -port $clientVMData.SSHPort -files ".\$constantsFile,.\remote-scripts\performance_middleware_mongod.sh,.\remote-scripts\run-ycsb.sh,.\$LogDir\StartMONGODTest.sh,.\$LogDir\workloadAzure" -username "root" -password $password -upload  2>&1 | Out-Null
		$out = RunLinuxCmd -ip $clientVMData.PublicIP -port $clientVMData.SSHPort -username "root" -password $password -command "chmod +x *.sh"
		$testJob = RunLinuxCmd -ip $clientVMData.PublicIP -port $clientVMData.SSHPort -username "root" -password $password -command "/root/StartMONGODTest.sh" -RunInBackground
		#endregion

		#region MONITOR TEST
		while ( (Get-Job -Id $testJob).State -eq "Running" )
		{
			$currentStatus = RunLinuxCmd -ip $clientVMData.PublicIP -port $clientVMData.SSHPort -username "root" -password $password -command "tail -n 1 /root/mongodConsoleLogs.txt"
			$testEndStatus = RunLinuxCmd -ip $clientVMData.PublicIP -port $clientVMData.SSHPort -username "root" -password $password -command "cat /root/mongodConsoleLogs.txt | grep 'TEST END' | tail -1"
			$testStartStatus = RunLinuxCmd -ip $clientVMData.PublicIP -port $clientVMData.SSHPort -username "root" -password $password -command "cat /root/mongodConsoleLogs.txt | grep 'TEST RUNNING' | tail -1"
			LogMsg "Current Test Staus : $testEndStatus $testStartStatus `n $currentStatus"
			WaitFor -seconds 10
		}
		
		$out = RemoteCopy -downloadFrom $clientVMData.PublicIP -port $clientVMData.SSHPort -username "root" -password $password -download -downloadTo $LogDir -files "/root/mongodConsoleLogs.txt"  2>&1 | Out-Null
		$out = RemoteCopy -downloadFrom $clientVMData.PublicIP -port $clientVMData.SSHPort -username "root" -password $password -download -downloadTo $LogDir -files "/root/summary.log,/root/state.txt"  2>&1 | Out-Null
		$finalStatus = RunLinuxCmd -ip $clientVMData.PublicIP -port $clientVMData.SSHPort -username "root" -password $password -command "cat /root/state.txt"
		$mdSummary = Get-Content -Path "$LogDir\summary.log" -ErrorAction SilentlyContinue
        
		if ($finalStatus -imatch "TestCompleted")
		{
			foreach ($thread in $threads.Split(","))
			{
				$threadStatus = RunLinuxCmd -ip $clientVMData.PublicIP -port $clientVMData.SSHPort -username "root" -password $password -command "cat /root/benchmark/mongodb/logs/$thread/$thread.ycsb.run.log | grep 'OVERALL], Throughput'" -ignoreLinuxExitCode
				if (($threadStatus -imatch 'OVERALL') -and ($threadStatus -imatch 'Throughput'))
				{
					$overallThroghput = $threadStatus.Trim().Split()[2].Trim()
					$metaData = "$thread threads:  overallThroghput"
					$resultSummary +=  CreateResultSummary -testResult $overallThroghput -metaData $metaData -checkValues "PASS,FAIL,ABORTED" -testName $currentTestData.testName# if you want to publish all result then give here all test status possibilites. if you want just failed results, then give here just "FAIL". You can use any combination of PASS FAIL ABORTED and corresponding test results will be published!
				}
				else
				{
					$resultSummary +=  CreateResultSummary -testResult "ERROR: Result not found. Possible test error." -metaData $testType -checkValues "PASS,FAIL,ABORTED" -testName $currentTestData.testName
				}
			} 
		}
		else
		{
			$overallThroghput = ""
		 }
		#endregion
		
		
		if (!$mdSummary)
		{
			LogMsg "summary.log file is empty."
			$mdSummary = $finalStatus
		}
		if ( $finalStatus -imatch "TestFailed")
		{
			LogErr "Test failed. Last known status : $currentStatus."
			$testResult = "FAIL"
		}
		elseif ( $finalStatus -imatch "TestAborted")
		{
			LogErr "Test Aborted. Last known status : $currentStatus."
			$testResult = "ABORTED"
		}
		elseif ( $finalStatus -imatch "TestCompleted")
		{
			LogMsg "Test Completed. Result : $finalStatus."
			$testResult = "PASS"
			$out = RemoteCopy -downloadFrom $clientVMData.PublicIP -port $clientVMData.SSHPort -username "root" -password $password -download -downloadTo $LogDir -files "/root/client-benchmark.tar.gz"  2>&1 | Out-Null
			$out = RemoteCopy -downloadFrom $clientVMData.PublicIP -port $serverVMData.SSHPort -username "root" -password $password -download -downloadTo $LogDir -files "/root/server-benchmark.tar.gz"  2>&1 | Out-Null
		}
		elseif ( $finalStatus -imatch "TestRunning")
		{
			LogMsg "Powershell backgroud job for test is completed but VM is reporting that test is still running. Please check $LogDir\mdConsoleLogs.txt"
			LogMsg "Contests of state.txt : $finalStatus"
			$testResult = "PASS"
		}
		LogMsg "Test result : $testResult"
		LogMsg "Test Completed"
	}
	catch
	{
		$ErrorMessage =  $_.Exception.Message
		LogMsg "EXCEPTION : $ErrorMessage"   
	}
	Finally
	{
		$metaData = ""
		if (!$testResult)
		{
			$testResult = "Aborted"
		}
		$resultArr += $testResult
	}   
}

else
{
	$testResult = "Aborted"
	$resultArr += $testResult
}

$result = GetFinalResultHeader -resultarr $resultArr

#Clean up the setup
#DoTestCleanUp -result $result -testName $currentTestData.testName -deployedServices $isDeployed -ResourceGroups $isDeployed

#Return the result and summery to the test suite script..
return $result, $resultSummary